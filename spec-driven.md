# 規格驅動開發(SDD)

## 權力反轉

幾十年來, 程式碼一直是王者. 規格服務於程式碼——它們是我們搭建的鷹架, 一旦編碼的"真正工作"開始, 就會被丟棄.

我們編寫 PRD 來指導開發, 建立設計文件來告知實現, 繪製圖表來視覺化架構. 但這些總是從屬於程式碼本身. 程式碼就是真理, 其他一切都只是良好的意圖.

程式碼是真理的來源, 隨著它的發展, 規格很少能跟上步伐. 由於資產(程式碼)和實現是一體的, 如果不試圖從程式碼構建, 就很難有並行實現.

規格驅動開發(SDD)顛覆了這種權力結構. 規格不為程式碼服務——程式碼為規格服務.

產品需求文件(PRD)不是實現的指南; 它是生成實現的來源. 技術計劃不是告知編碼的文件; 它們是產生程式碼的精確定義. 這不是對軟體構建方式的漸進式改進, 這是對驅動開發內容的根本性重新思考.

規格與實現之間的差距自軟體誕生以來就一直困擾著軟體開發.

我們試圖透過更好的文件、更詳細的需求、更嚴格的流程來彌合這一差距. 這些方法之所以失敗, 是因為它們認為差距是不可避免的. 它們試圖縮小差距, 但從未消除它.

SDD透過使規格及其從規格產生的具體實現計劃可執行來消除差距. 當規格到實現計劃生成程式碼時, 就沒有差距——只有轉換.

這種轉換現在之所以可能, 是因為AI能夠理解和實現複雜的規格, 並建立詳細的實現計劃. 但是沒有結構的原始AI生成會產生混亂. SDD透過精確、完整和明確的規格及後續實現計劃來提供這種結構, 足以生成工作系統. 規格成為主要製品. 程式碼成為其在特定語言和框架中的表達(作為實現計劃的實現).

在這個新世界中, 維護軟體意味著演進規格. 開發團隊的意圖用自然語言("**意圖驅動開發**")、設計資產、核心原則和其他指導方針來表達. 開發的**通用語言**移動到更高層次, 而程式碼是最後一英里的方法.

除錯意味著修復生成錯誤程式碼的規格及其實現計劃. 重構意味著為了清晰而重組. 整個開發工作流程圍繞規格作為中心真理來源重新組織, 實現計劃和程式碼作為持續再生的輸出. 使用新功能更新應用程式或建立新的並行實現, 因為我們是有創造力的生物, 意味著重新審視規格並建立新的實現計劃. 因此這個過程是0 -> 1, (1', ..), 2, 3, N.

開發團隊專注於他們的創造力、實驗性和批判性思維.

## SDD工作流程實踐

工作流程從一個想法開始——通常是模糊和不完整的. 透過與AI的迭代對話, 這個想法成為一個全面的PRD. AI提出澄清問題, 識別邊界情況, 並幫助定義精確的驗收標準. 在傳統開發中可能需要幾天會議和文件的工作, 在幾小時的專注規格工作中就完成了. 這改變了傳統的SDLC——需求和設計成為持續活動而不是離散階段. 這支援**團隊流程**, 即團隊審查的規格被表達和版本控制, 在分支中建立, 併合並.

當產品經理更新驗收標準時, 實現計劃會自動標記受影響的技術決策. 當架構師發現更好的模式時, PRD會更新以反映新的可能性.

在整個規格過程中, 研究代理收集關鍵上下文. 他們調查庫相容性、效能基準和安全影響. 組織約束被自動發現和應用——你公司的資料庫標準、身份驗證要求和部署策略無縫整合到每個規格中.

從PRD, AI生成將需求對映到技術決策的實現計劃. 每個技術選擇都有記錄的基本原理. 每個架構決策都可追溯到特定需求. 在整個過程中, 一致性驗證持續提高品質. AI分析規格的模糊性、矛盾和差距——不是作為一次性關卡, 而是作為持續改進.

一旦規格及其實現計劃足夠穩定, 就可以開始程式碼生成, 但它們不必"完整". 早期生成可能是探索性的——測試規格在實踐中是否有意義. 域概念成為資料模型. 使用者故事成為API端點. 驗收場景成為測試. 這透過規格將開發和測試合併——測試場景不是在程式碼之後編寫, 它們是生成實現和測試的規格的一部分.

反饋迴圈擴充套件到初始開發之外. 生產指標和事件不僅觸發熱修復——它們還為下一次再生更新規格. 效能瓶頸成為新的非功能性需求. 安全漏洞成為影響所有未來生成的約束. 規格、實現和運營現實之間的這種迭代舞蹈是真正理解出現的地方, 也是傳統SDLC轉變為持續演進的地方.

## 為什麼SDD現在重要

三大趨勢使SDD不僅可能而且必要: 

首先, AI能力已經達到一個門檻, 自然語言規格可以可靠地生成工作程式碼. 這不是關於取代開發者——而是透過自動化從規格到實現的機械轉換來放大他們的效果. 它可以放大探索和創造力, 它可以輕鬆支援"重新開始", 它支援加法減法和批判性思維.

其次, 軟體複雜性繼續呈指數級增長. 現代系統集成了數十個服務、框架和依賴項. 透過手動流程保持所有這些部分與原始意圖一致變得越來越困難. SDD透過規格驅動的生成提供系統性一致性. 框架可能會發展以提供AI優先支援, 而不是人類優先支援, 或者圍繞可重用元件進行架構設計.

第三, 變化的速度加快. 需求現在比以往任何時候變化得更快. 轉向不再例外——它是預期的. 現代產品開發需要基於使用者反饋、市場條件和競爭壓力進行快速迭代. 傳統開發將這些變化視為干擾. 每次轉向都需要手動傳播文件、設計和程式碼的變更. 結果要麼是限制速度的緩慢、謹慎的更新, 要麼是累積技術債務的快速、魯莽的變化.

SDD可以支援假設/模擬實驗, "如果我們需要重新實現或更改應用程式以促進銷售更多T恤的業務需求, 我們將如何實現和實驗？"

SDD將需求變更從障礙轉變為正常工作流程. 當規格驅動實現時, 轉向成為系統性再生而不是手動重寫. 更改PRD中的核心需求, 受影響的實現計劃會自動更新. 修改使用者故事, 相應的API端點會重新生成. 這不僅關乎初始開發——還關乎透過不可避免的變化保持工程速度.

## 核心原則

**規格作為通用語言**: 規格成為主要製品. 程式碼成為其在特定語言和框架中的表達. 維護軟體意味著演進規格.

**可執行規格**: 規格必須精確、完整和明確, 足以生成工作系統. 這消除了意圖和實現之間的差距.

**持續改進**: 一致性驗證持續發生, 而不是作為一次性關卡. AI作為持續過程分析規格的模糊性、矛盾和差距.

**研究驅動的上下文**: 研究代理在整個規格過程中收集關鍵上下文, 調查技術選項、效能影響和組織約束.

**雙向反饋**: 生產現實告知規格演進. 指標、事件和運營學習成為規格改進的輸入.

**探索性分支**: 從同一規格生成多種實現方法, 以探索不同的最佳化目標——效能、可維護性、使用者體驗、成本.

## 實現方法

今天, 實踐SDD需要組裝現有工具並在整個過程中保持紀律. 該方法可以透過以下方式實踐: 

- 用於迭代規格開發的AI助手
- 用於收集技術上下文的研究代理
- 用於將規格轉換為實現的程式碼生成工具
- 適應規格優先工作流程的版本控制系統
- 透過AI分析規格文件進行一致性檢查

關鍵是將規格視為真理來源, 程式碼作為生成的輸出為規格服務, 而不是相反.

## 透過命令簡化SDD

SDD方法透過三個強大的命令得到顯著增強, 這些命令自動化了規格→計劃→任務工作流程:

### `/speckit.specify` 命令

此命令將簡單的功能描述(使用者提示)轉換為完整的結構化規格, 並具有自動儲存庫管理:

1. **自動功能編號**: 掃描現有規格以確定下一個功能編號(例如, 001、002、003)
2. **分支建立**: 從你的描述生成語義分支名稱並自動建立
3. **基於模板的生成**: 使用你的需求複製和自定義功能規格模板
4. **目錄結構**: 為所有相關文件建立適當的`specs/[branch-name]/`結構

### `/speckit.plan` 命令

一旦功能規格存在, 此命令建立全面的實現計劃:

1. **規格分析**: 閱讀和理解功能需求、使用者故事和驗收標準
2. **章程合規性**: 確保與專案章程和架構原則一致
3. **技術轉換**: 將業務需求轉換為技術架構和實現細節
4. **詳細文件**: 為資料模型、API合同和測試場景生成支援文件
5. **快速啟動驗證**: 產生捕獲關鍵驗證場景的快速啟動指南

### `/speckit.tasks` 命令

計劃建立後, 此命令分析計劃和相關設計文件以生成可執行的任務列表:

1. **輸入**: 讀取`plan.md`(必需)以及(如果存在)`data-model.md`、`contracts/`和`research.md`
2. **任務推導**: 將合同、實體和場景轉換為特定任務
3. **並行化**: 標記獨立任務`[P]`並概述安全的並行組
4. **輸出**: 在功能目錄中寫入`tasks.md`, 準備好由Task代理執行

### 範例: 構建聊天功能

以下是這些命令如何改變傳統開發工作流程: 

**傳統方法: **

```text
1. 在文件中編寫PRD(2-3小時)
2. 建立設計文件(2-3小時)
3. 手動設定專案結構(30分鐘)
4. 編寫技術規格(3-4小時)
5. 建立測試計劃(2小時)
總計: 約12小時的文件工作
```

**使用命令的SDD方法: **

```bash
# 步驟1: 建立功能規格(5分鐘)
/speckit.specify 具有訊息歷史記錄和使用者狀態的即時聊天系統

# 這自動: 
# - 建立分支"003-chat-system"
# - 生成specs/003-chat-system/spec.md
# - 用結構化需求填充它

# 步驟2: 生成實現計劃(5分鐘)
/speckit.plan WebSocket用於即時訊息傳遞, PostgreSQL用於歷史記錄, Redis用於狀態

# 步驟3: 生成可執行任務(5分鐘)
/speckit.tasks

# 這自動建立: 
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md(WebSocket庫比較)
# - specs/003-chat-system/data-model.md(訊息和使用者模式)
# - specs/003-chat-system/contracts/(WebSocket事件, REST端點)
# - specs/003-chat-system/quickstart.md(關鍵驗證場景)
# - specs/003-chat-system/tasks.md(從計劃派生的任務列表)
```

在15分鐘內, 你擁有: 

- 具有使用者故事和驗收標準的完整功能規格
- 具有技術選擇和基本原理的詳細實現計劃
- 準備好程式碼生成的API合同和資料模型
- 自動化和手動測試的綜合測試場景
- 所有文件都在功能分支中正確版本控制

### 結構化自動化的力量

這些命令不僅節省時間——它們強制一致性和完整性: 

1. **無遺忘細節**: 模板確保考慮每個方面, 從非功能性需求到錯誤處理
2. **可追溯決策**: 每個技術選擇都連結回特定需求
3. **活文件**: 規格與程式碼保持同步, 因為它們生成程式碼
4. **快速迭代**: 在幾分鐘內更改需求和重新生成計劃, 而不是幾天

這些命令透過將規格視為可執行製品而不是靜態文件來體現SDD原則. 它們將規格過程從必要的邪惡轉變為發展的驅動力.

### 模板驅動的品質: 結構如何約束LLM以取得更好的結果

這些命令的真正力量不僅在於自動化, 還在於模板如何引導LLM行為產生更高品質的規格. 模板充當複雜的提示, 以生產性的方式約束LLM的輸出: 

#### 1. **防止過早的實現細節**

功能規格模板明確指示: 

```text
- ✅ 專注於使用者需要什麼和為什麼
- ❌ 避免如何實現(無技術堆疊、API、程式碼結構)
```

這種約束迫使LLM保持適當的抽象級別. 當LLM可能自然跳轉到"使用React和Redux實現"時, 模板保持其專注於"使用者需要其資料的即時更新". 這種分離確保規格即使在實現技術發生變化時也保持穩定.

#### 2. **強制明確的不確定性標記**

兩個模板都強制使用`[NEEDS CLARIFICATION]`標記: 

```text
從使用者提示建立此規格時: 
1. **標記所有模糊性**: 使用[NEEDS CLARIFICATION: 具體問題]
2. **不要猜測**: 如果提示沒有指定某些內容, 請標記它
```

這可以防止LLM做出合理但可能不正確的假設的常見行為. LLM不能猜測"登入系統"使用電子郵件/密碼身份驗證, 而是必須將其標記為`[NEEDS CLARIFICATION: 未指定身份驗證方法 - 電子郵件/密碼、SSO、OAuth？]`.

#### 3. **透過清單進行結構化思維**

模板包含全面的清單, 充當規格的"單元測試": 

```markdown
### 需求完整性
- [ ] 沒有[NEEDS CLARIFICATION]標記剩餘
- [ ] 需求是可測試和明確的
- [ ] 成功標準是可衡量的
```

這些清單迫使LLM系統地自我審查其輸出, 捕獲可能遺漏的差距. 這就像給LLM一個品質保證框架.

#### 4. **透過關卡實現章程合規性**

實現計劃模板透過階段關卡強制執行架構原則: 

```markdown
### 階段-1: 實現前關卡
#### 簡單性關卡(第七條)
- [ ] 使用≤3個專案？
- [ ] 沒有未來驗證？

#### 反抽象關卡(第八條)
- [ ] 直接使用框架？
- [ ] 單一模型表示？
```

這些關卡透過使LLM明確證明任何複雜性來防止過度工程. 如果關卡失敗, LLM必須在"複雜性跟蹤"部分記錄原因, 為架構決策建立問責制.

#### 5. **分層細節管理**

模板強制執行適當的資訊架構: 

```text
**重要**: 此實現計劃應保持高級別和可讀性.
任何程式碼範例、詳細演算法或廣泛的技術規格
必須放在適當的`implementation-details/`檔案中
```

這可以防止規格成為不可讀的程式碼轉儲的常見問題. LLM學會保持適當的細節級別, 將複雜性提取到單獨的檔案中, 同時保持主要文件可導航.

#### 6. **測試優先思維**

實現模板強制執行測試優先開發: 

```text
### 檔案建立順序
1. 建立具有API規格的`contracts/`
2. 按順序建立測試檔案: contract → integration → e2e → unit
3. 建立原始檔以使測試透過
```

這種排序約束確保LLM在實現之前考慮可測試性和合同, 導致更強大和可驗證的規格.

#### 7. **防止投機性功能**

模板明確阻止投機: 

```text
- [ ] 沒有投機性或"可能需要"的功能
- [ ] 所有階段都有明確的先決條件和可交付成果
```

這阻止LLM新增使實現複雜化的"很好有"功能. 每個功能都必須追溯到具有明確驗收標準的具體使用者故事.

### 複合效應

這些約束一起產生以下特點的規格: 

- **完整**: 清單確保不會忘記任何內容
- **明確**: 強制澄清標記突出不確定性
- **可測試**: 測試優先思維融入過程
- **可維護**: 適當的抽象級別和資訊層次
- **可實現**: 具有具體可交付成果的明確階段

模板將LLM從創意作家轉變為紀律嚴明的規格工程師, 引導其能力產生始終如一的高品質、可執行規格, 真正驅動開發.

## 專案章程基礎: 強制執行架構紀律

SDD的核心是一套章程——一套不可變的原則, 管理規格如何成為程式碼. 專案章程(`memory/constitution.md`)充當系統的架構DNA, 確保每個生成的實現保持一致性、簡單性和品質.

### 開發的九條條款

專案章程定義了塑造開發過程各個方面的九條條款: 

#### 第一條: 庫優先原則

每個功能必須作為獨立庫開始——沒有例外. 這從一開始就強制模組化設計: 

```text
Specify中的每個功能必須作為獨立庫開始其存在.
任何功能都不得直接在應用程式程式碼中實現, 
除非首先被抽象為可重用的庫元件.
```

這一原則確保規格生成模組化、可重用的程式碼, 而不是單體應用程式. 當LLM生成實現計劃時, 它必須將功能構造為具有清晰邊界和最小依賴關係的庫.

#### 第二條: CLI介面強制要求

每個庫必須透過命令列介面公開其功能: 

```text
所有CLI介面必須: 
- 接受文字作為輸入(透過stdin、引數或檔案)
- 產生文字作為輸出(透過stdout)
- 支援JSON格式進行結構化資料交換
```

這強制執行可觀察性和可測試性. LLM不能將功能隱藏在不透明的類中——一切都必須透過基於文字的介面可訪問和可驗證.

#### 第三條: 測試優先命令

最具變革性的條款——沒有測試就沒有程式碼: 

```text
這是不可協商的: 所有實現必須遵循嚴格的測試驅動開發.
在之前不得編寫任何實現程式碼: 
1. 單元測試已編寫
2. 測試已由使用者驗證和批准
3. 測試確認為失敗(紅色階段)
```

這完全顛覆了傳統的AI程式碼生成. LLM不是生成程式碼並希望它工作, 而是必須首先定義行為的綜合測試, 取得它們批准, 然後才生成實現.

#### 第七條和第八條: 簡單性和反抽象

這些配對條款對抗過度工程: 

```text
第7.3節: 最小專案結構
- 初始實現最多3個專案
- 額外專案需要記錄的基本原理

第8.1節: 框架信任
- 直接使用框架功能而不是包裝它們
```

當LLM可能自然建立精心製作的抽象時, 這些條款迫使它證明每一層複雜性. 實現計劃模板的"階段-1關卡"直接強制執行這些原則.

#### 第九條: 整合優先測試

優先考慮真實世界測試而不是孤立的單元測試: 

```text
測試必須使用真實環境: 
- 優先使用真實資料庫而不是模擬
- 使用實際服務例項而不是存根
- 實現前的強制合同測試
```

這確保生成的程式碼在實踐中有效, 而不僅僅是在理論上.

### 透過模板強制執行專案章程

實現計劃模板透過具體檢查點操作這些條款: 

```markdown
### 階段-1: 實現前關卡
#### 簡單性關卡(第七條)
- [ ] 使用≤3個專案？
- [ ] 沒有未來驗證？

#### 反抽象關卡(第八條)
- [ ] 直接使用框架？
- [ ] 單一模型表示？

#### 整合優先關卡(第九條)
- [ ] 合同已定義？
- [ ] 合同測試已編寫？
```

這些關卡充當架構原則的編譯時檢查. LLM無法繼續, 除非透過關卡或在"複雜性跟蹤"部分記錄證明的例外.

### 不可變原則的力量

專案章程的力量在於其不可變性. 雖然實現細節可以演進, 但核心原則保持不變. 這提供: 

1. **時間一致性**: 今天生成的程式碼遵循與明年生成的程式碼相同的原則
2. **LLM一致性**: 不同的AI模型產生架構相容的程式碼
3. **架構完整性**: 每個功能加強而不是破壞系統設計
4. **品質保證**: 測試優先、庫優先和簡單性原則確保可維護程式碼

### 專案章程演進

雖然原則是不可變的, 但它們的應用可以演進: 

```text
第4.2節: 修正過程
對本專案章程的修改需要: 
- 變更基本原理的明確文件
- 專案維護者的審查和批准
- 向後相容性評估
```

這允許方法論在學習的同時保持穩定. 專案章程顯示其自身的演進, 帶有日期修正, 展示瞭如何基於實際經驗完善原則.

### 超越規則: 開發哲學

專案章程不僅僅是規則書——它是一種塑造LLM如何思考程式碼生成的哲學: 

- **可觀察性優於不透明性**: 一切都必須透過CLI介面可檢查
- **簡單性優於聰明**: 從簡單開始, 僅在證明必要時新增複雜性
- **整合優於隔離**: 在真實環境中測試, 而不是人工環境
- **模組化優於單體**: 每個功能都是具有清晰邊界的庫

透過將這些原則嵌入規格和規劃過程, SDD確保生成的程式碼不僅是功能性的——它是可維護的、可測試的和架構合理的. 專案章程將AI從程式碼生成器轉變為尊重和加強系統設計原則的架構夥伴.

## 轉型

這不是關於取代開發者或自動化創造力. 這是透過自動化機械轉換來放大人類能力. 這是關於建立一個緊密的反饋迴圈, 其中規格、研究和程式碼一起演進, 每次迭代都帶來更深的理解和意圖與實現之間更好的對齊.

軟體開發需要更好的工具來保持意圖和實現之間的一致性. SDD提供了透過生成程式碼而不是僅僅指導程式碼的可執行規格來實現這種一致性的方法論.
