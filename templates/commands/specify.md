---
description: 從自然語言功能描述建立或更新功能規格.
handoffs:
  - label: 構建技術計劃
    agent: speckit.plan
    prompt: 為規格建立計劃。我正在構建...
  - label: 澄清規格需求
    agent: speckit.clarify
    prompt: 分析規格的完整性和清晰度
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 使用者輸入

```text
$ARGUMENTS
```

在繼續之前, 你**必須**考慮使用者輸入(如果不為空).

## 概述

使用者在觸發訊息中 `/speckit.specify` 後輸入的文字**就是**功能描述. 假設你始終可以在本次對話中訪問它, 即使下面字面上顯示 `{ARGS}`. 除非使用者提供了空命令, 否則不要要求使用者重複.

基於該功能描述, 執行以下操作:

1. **為分支生成一個簡短名稱**(2-4個詞):
   - 分析功能描述並提取最有意義的關鍵詞
   - 建立一個2-4個詞的簡短名稱, 捕捉功能的核心
   - 儘可能使用動-名詞格式(例如, "add-user-auth", "fix-payment-bug")
   - 保留技術術語和縮寫(OAuth2、API、JWT等)
   - 保持簡潔但足夠描述性, 便於快速理解功能
   - 範例:
     - "I want to add user authentication" → "user-auth"
     - "Implement OAuth2 integration for the API" → "oauth2-api-integration"
     - "Create a dashboard for analytics" → "analytics-dashboard"
     - "Fix payment processing timeout bug" → "fix-payment-timeout"

2. 從倉庫根目錄執行指令碼 `{SCRIPT}` **使用簡短名稱引數**並解析其 JSON 輸出以獲取 BRANCH_NAME 和 SPEC_FILE. 所有檔案路徑必須是絕對路徑.

   **重要說明**:

   - 將第1步建立的2-4詞簡短名稱作為引數附加到 `{SCRIPT}` 命令, 功能描述作為最終引數.
   - Bash 範例: `--short-name "your-generated-short-name" "功能描述內容"`
   - PowerShell 範例: `-ShortName "your-generated-short-name" "功能描述內容"`
   - 對於引數中包含單引號的情況(如 "I'm Groot"), 使用轉義語法: 例如 'I'\''m Groot'(或優先使用雙引號: "I'm Groot")
   - 你必須且只能執行此指令碼一次
   - JSON 輸出會顯示在終端中 - 請始終參考該輸出來獲取你要查詢的實際內容

3. 載入 `templates/spec-template.md` 以瞭解必需的章節.

4. 遵循此執行流程:

    1. 從輸入解析使用者描述
       如果為空: 錯誤 "未提供功能描述"
    2. 從描述中提取關鍵概念
       識別: 參與者、操作、資料、約束
    3. 對於不明確的方面: 
       - 基於上下文和行業標準做出有根據的猜測
       - 僅在以下情況下標記為 [NEEDS CLARIFICATION: 具體問題]: 
         - 選擇顯著影響功能範圍或使用者體驗
         - 存在多個合理的解釋且有不同的含義
         - 沒有合理的預設值
       - **限制: 最多 3 個 [NEEDS CLARIFICATION] 標記**
       - 按影響優先順序排序: 範圍 > 安全/隱私 > 使用者體驗 > 技術細節
    4. 填寫使用者場景和測試章節
       如果沒有明確的使用者流程: 錯誤 "無法確定使用者場景"
    5. 生成功能需求
       每個需求必須是可測試的
       對未指定的細節使用合理的預設值(在假設章節中記錄假設)
    6. 定義成功標準
       建立可衡量的、技術無關的結果
       包括定量指標(時間、效能、數量)和定性措施(使用者滿意度、任務完成)
       每個標準必須無需實現細節即可驗證
    7. 識別關鍵實體(如果涉及資料)
    8. 返回: 成功(規格準備好進行規劃)

5. 使用模板結構將規格寫入 SPEC_FILE, 用從功能描述(引數)派生的具體細節替換佔位符, 同時保持章節順序和標題.

6. **規格品質驗證**: 編寫初始規格後, 根據品質標準進行驗證:

   a. **建立規格品質檢查清單**: 使用檢查清單模板結構在 `FEATURE_DIR/checklists/requirements.md` 生成檢查清單檔案, 包含這些驗證專案:

      ```markdown
      # 規格品質檢查清單: [功能名稱]

      **目的**: 在繼續規劃之前驗證規格的完整性和品質
      **建立時間**: [日期]
      **功能**: [指向 spec.md 的連結]

      ## 內容品質

      - [ ] 無實現細節(語言、框架、API)
      - [ ] 專注於使用者價值和業務需求
      - [ ] 為非技術利益相關者編寫
      - [ ] 所有必需章節已完成

      ## 需求完整性

      - [ ] 沒有 [NEEDS CLARIFICATION] 標記剩餘
      - [ ] 需求是可測試且明確的
      - [ ] 成功標準是可衡量的
      - [ ] 成功標準是技術無關的(無實現細節)
      - [ ] 所有驗收場景已定義
      - [ ] 邊緣情況已識別
      - [ ] 範圍明確界定
      - [ ] 依賴關係和假設已識別

      ## 功能準備就緒

      - [ ] 所有功能需求都有明確的驗收標準
      - [ ] 使用者場景覆蓋主要流程
      - [ ] 功能滿足成功標準中定義的可衡量結果
      - [ ] 沒有實現細節洩漏到規格中

      ## 備註

      - 標記為不完整的專案需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新規格
      ```

   b. **執行驗證檢查**: 根據每個檢查清單專案審查規格:
      - 對於每個專案, 確定是否透過或失敗
      - 記錄發現的具體問題(引用相關規格章節)

   c. **處理驗證結果**:

      - **如果所有專案都透過**: 標記檢查清單完成並繼續步驟 7

      - **如果專案失敗(不包括 [NEEDS CLARIFICATION])**:
        1. 列出失敗的專案和具體問題
        2. 更新規格以解決每個問題
        3. 重新執行驗證直到所有專案都透過(最多 3 次迭代)
        4. 如果 3 次迭代後仍然失敗, 在檢查清單備註中記錄剩餘問題並警告使用者

      - **如果 [NEEDS CLARIFICATION] 標記仍然存在**:
        1. 從規格中提取所有 [NEEDS CLARIFICATION: ...] 標記
        2. **限制檢查**: 如果存在超過 3 個標記, 僅保留 3 個最關鍵的(按範圍/安全/使用者體驗影響)併為其餘部分做出有根據的猜測
        3. 對於每個需要的澄清(最多 3 個), 以以下格式向用戶呈現選項:

           ```markdown
           ## 問題 [N]: [主題]

           **上下文**: [引用相關規格章節]

           **我們需要了解**: [來自 NEEDS CLARIFICATION 標記的具體問題]

           **建議答案**:

           | 選項 | 答案 | 含義 |
           |--------|--------|--------------|
           | A      | [第一個建議答案] | [這對功能意味著什麼] |
           | B      | [第二個建議答案] | [這對功能意味著什麼] |
           | C      | [第三個建議答案] | [這對功能意味著什麼] |
           | 自定義 | 提供你自己的答案 | [解釋如何提供自定義輸入] |

           **你的選擇**: _[等待使用者響應]_
           ```

        4. **關鍵 - 表格格式**: 確保 markdown 表格格式正確:
           - 使用一致的間距, 管道符對齊
           - 每個單元格內容周圍應有空格: `| 內容 |` 而不是 `|內容|`
           - 標題分隔符必須至少有 3 個破折號: `|--------|`
           - 測試表格在 markdown 預覽中正確渲染
        5. 按順序編號問題(Q1、Q2、Q3 - 最多 3 個)
        6. 在等待響應之前一起呈現所有問題
        7. 等待使用者響應所有問題的選擇(例如, "Q1: A, Q2: 自定義 - [詳情], Q3: B")
        8. 透過用使用者選擇或提供的答案替換每個 [NEEDS CLARIFICATION] 標記來更新規格
        9. 在所有澄清解決後重新執行驗證

   d. **更新檢查清單**: 每次驗證迭代後, 使用當前的透過/失敗狀態更新檢查清單檔案

7. 報告完成情況, 包括分支名稱、規格檔案路徑、檢查清單結果以及下一階段(`/speckit.clarify` 或 `/speckit.plan`)的準備就緒狀態.

**注意**: 指令碼在寫入之前建立並檢出新分支並初始化規格檔案.

## 通用指南

## 快速指南

- 專注於使用者需要**什麼**和**為什麼**.
- 避免如何實現(不涉及技術棧、API、程式碼結構).
- 為業務利益相關者編寫, 而不是為開發者.
- 不要建立嵌入規格中的任何檢查清單. 那將是一個單獨的命令.

### 章節要求

- **必需章節**: 每個功能必須完成
- **可選章節**: 僅在與功能相關時包含
- 當章節不適用時, 完全刪除它(不要保留為 "N/A")

### AI 生成

當從使用者提示建立此規格時: 

1. **做出有根據的猜測**: 使用上下文、行業標準和常見模式來填補空白
2. **記錄假設**: 在假設章節中記錄合理的預設值
3. **限制澄清**: 最多 3 個 [NEEDS CLARIFICATION] 標記 - 僅用於關鍵決策: 
   - 顯著影響功能範圍或使用者體驗
   - 存在多個合理的解釋且有不同的含義
   - 缺乏任何合理的預設值
4. **優先澄清**: 範圍 > 安全/隱私 > 使用者體驗 > 技術細節
5. **像測試人員一樣思考**: 每個模糊的需求都應該在"可測試且明確"的檢查清單專案上失敗
6. **NEEDS CLARIFICATION 的常見領域**(僅在沒有合理預設值時): 
   - 功能範圍和邊界(包含/排除特定用例)
   - 使用者型別和許可權(如果可能存在多個衝突的解釋)
   - 安全/合規要求(當具有法律/財務重要性時)

**合理預設值的範例**(不要詢問這些): 

- 資料保留: 該行業的行業標準實踐
- 效能目標: 標準 Web/移動應用期望, 除非另有說明
- 錯誤處理: 使用者友好的訊息和適當的回退
- 認證方法: Web 應用的標準基於會話或 OAuth2
- 整合模式: RESTful API, 除非另有說明

### 成功標準指南

成功標準必須是: 

1. **可衡量的**: 包括具體指標(時間、百分比、計數、速率)
2. **技術無關的**: 不提及框架、語言、資料庫或工具
3. **以使用者為中心的**: 從使用者/業務角度描述結果, 而不是系統內部
4. **可驗證的**: 無需瞭解實現細節即可測試/驗證

**好的範例**: 

- "使用者可以在 3 分鐘內完成結賬"
- "系統支援 10,000 個併發使用者"
- "95% 的搜尋在 1 秒內返回結果"
- "任務完成率提高 40%"

**壞的範例**(以實現為中心): 

- "API 響應時間在 200ms 以下"(太技術化, 使用"使用者立即看到結果")
- "資料庫可以處理 1000 TPS"(實現細節, 使用面向使用者的指標)
- "React 元件高效渲染"(框架特定)
- "Redis 快取命中率超過 80%"(技術特定)
