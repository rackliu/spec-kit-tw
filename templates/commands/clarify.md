---
description: 透過提出最多 5 個高度針對性的澄清問題, 識別當前功能規格中未充分說明的領域, 並將答案編碼回規格中.
handoffs:
  - label: 構建技術計劃
    agent: speckit.plan
    prompt: 為規格建立計劃。我正在構建...
scripts:
   sh: scripts/bash/check-prerequisites.sh --json --paths-only
   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## 使用者輸入

```text
$ARGUMENTS
```

在繼續之前, 你**必須**考慮使用者輸入(如果不為空).

## 概述

目標: 檢測並減少活躍功能規格中的模糊性或缺失的決策點, 並將澄清內容直接記錄在規格檔案中.

注意: 此澄清工作流應在呼叫 `/speckit.plan` 之前執行(並完成). 如果使用者明確表示他們跳過澄清(例如, 探索性原型), 你可以繼續, 但必須警告下游返工風險增加.

執行步驟: 

1. 從倉庫根目錄執行 `{SCRIPT}` **一次**(組合 `--json --paths-only` 模式 / `-Json -PathsOnly`). 解析最小 JSON 負載欄位: 
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - (可選捕獲 `IMPL_PLAN`、`TASKS` 用於未來的鏈式流程. )
   - 如果 JSON 解析失敗, 中止並指示使用者重新執行 `/speckit.specify` 或驗證功能分支環境.
   - 對於引數中包含單引號的情況(如 "I'm Groot"), 使用轉義語法: 例如 'I'\''m Groot'(或優先使用雙引號: "I'm Groot").

2. 載入當前規格檔案. 使用此分類法執行結構化模糊性和覆蓋範圍掃描. 對於每個類別, 標記狀態: 清晰 / 部分 / 缺失. 生成用於優先順序排序的內部覆蓋範圍圖(除非不會提問, 否則不輸出原始圖).

   功能範圍與行為: 
   - 核心使用者目標和成功標準
   - 明確的超出範圍宣告
   - 使用者角色 / 角色區分

   領域與資料模型: 
   - 實體、屬性、關係
   - 身份和唯一性規則
   - 生命週期 / 狀態轉換
   - 資料量 / 規模假設

   互動與 UX 流程: 
   - 關鍵使用者旅程 / 序列
   - 錯誤 / 空白 / 載入狀態
   - 可訪問性或本地化說明

   非功能性品質屬性: 
   - 效能(延遲、吞吐量目標)
   - 可擴充套件性(水平 / 垂直、限制)
   - 可靠性和可用性(正常執行時間、恢復期望)
   - 可觀察性(日誌、指標、追蹤訊號)
   - 安全性和隱私(身份驗證 / 授權、資料保護、威脅假設)
   - 合規性 / 監管約束(如有)

   整合與外部依賴: 
   - 外部服務 / API 和故障模式
   - 資料匯入 / 匯出格式
   - 協議 / 版本控制假設

   邊緣情況與故障處理: 
   - 負面場景
   - 速率限制 / 節流
   - 衝突解決(例如, 併發編輯)

   約束與權衡: 
   - 技術約束(語言、儲存、託管)
   - 明確的權衡或被拒絕的替代方案

   術語與一致性: 
   - 規格術語表術語
   - 避免的同義詞 / 已棄用術語

   完成訊號: 
   - 驗收標準可測試性
   - 可衡量的完成定義風格指標

   其他 / 佔位符: 
   - TODO 標記 / 未解決的決策
   - 缺少量化的模糊形容詞("robust"、"intuitive")

   對於每個處於部分或缺失狀態的類別, 新增候選問題機會, 除非: 
   - 澄清不會實質性地改變實施或驗證策略
   - 資訊更適合推遲到規劃階段(內部記錄)

3. (內部)生成候選澄清問題的優先順序佇列(最多5個). 不要一次性輸出所有問題. 應用這些約束: 
    - 整個會話最多10個問題.
    - 每個問題必須可以用以下任一方式回答: 
       * 簡短的多項選擇(2-5個不同的、互斥的選項), 或
       * 單詞 / 短語答案(明確約束: "Answer in <=5 words").
    - 僅包含答案實質上影響架構、資料建模、任務分解、測試設計、UX 行為、運營準備或合規性驗證的問題.
    - 確保類別覆蓋平衡: 嘗試首先覆蓋最高影響的未解決類別; 避免在單個高影響領域(例如, 安全態勢)未解決時詢問兩個低影響問題.
    - 排除已回答的問題、瑣碎的風格偏好或規劃級別的執行細節(除非阻礙正確性).
    - 偏好減少下游返工風險或防止不一致驗收測試的澄清.
    - 如果超過5個類別仍未解決, 透過(影響 * 不確定性)啟發式選擇前5個.

4. 順序提問流程(互動式): 
    - 一次只提出**確切一個**問題.
    - 對於多項選擇題: 
       * **分析所有選項**並基於以下確定**最合適的選項**: 
          - 專案型別的最佳實踐
          - 類似實現中的常見模式
          - 風險降低(安全性、效能、可維護性)
          - 與規格中可見的任何明確專案目標或約束的一致性
       * 在頂部突出顯示你的**推薦選項**並附上清晰推理(1-2句話解釋為什麼這是最佳選擇).
       * 格式為: `**Recommended:** Option [X] - <reasoning>`
       * 然後將所有選項渲染為 Markdown 表格: 

          | Option | Description |
          |--------|-------------|
          | A | <Option A description> |
          | B | <Option B description> |
          | C | <Option C description> | (根據需要新增 D/E, 最多5個)
          | Short | Provide a different short answer (<=5 words) | (僅在自由形式替代方案合適時包含)
       * 表格後新增: `You can reply with the option letter (e.g., "A"), accept the recommendation by saying "yes" or "recommended", or provide your own short answer.`
    - 對於簡答題風格(沒有有意義的不同選項): 
       * 基於最佳實踐和上下文提供你的**建議答案**.
       * 格式為: `**Suggested:** <your proposed answer> - <brief reasoning>`
       * 然後輸出: `Format: Short answer (<=5 words). You can accept the suggestion by saying "yes" or "suggested", or provide your own answer.`
    - 使用者回答後: 
       * 如果使用者回覆 "yes"、"recommended" 或 "suggested", 使用你之前陳述的推薦 / 建議作為答案.
       * 否則, 驗證答案對映到一個選項或符合 <=5 個詞的約束.
       * 如果模糊, 要求快速消除歧義(計數仍屬於同一問題; 不前進).
       * 一旦滿意, 將其記錄在工作記憶體中(尚未寫入磁碟)並移動到下一個排隊的問題.
    - 在以下情況時停止進一步提問: 
       * 所有關鍵模糊性早期解決(剩餘排隊專案變得不必要), 或
       * 使用者發出完成訊號("done"、"good"、"no more"), 或
       * 你達到5個已問問題.
    - 永遠不要提前揭示未來的排隊問題.
    - 如果開始時沒有有效問題, 立即報告沒有關鍵模糊性.

5. 每次接受答案後的整合(增量更新方法): 
    - 維護規格的記憶體表示(開始時載入一次)加上原始檔案內容.
    - 對於此會話中第一個整合的答案: 
       * 確保 `## Clarifications` 部分存在(如果缺失, 根據規格模板在最高級別的上下文 / 概述部分之後建立).
       * 在其下, 建立(如果不存在)今天的 `### Session YYYY-MM-DD` 子標題.
    - 接受後立即追加專案符號行: `- Q: <question> → A: <final answer>`.
    - 然後立即將澄清應用到最合適的部分: 
       * 功能模糊性 → 更新或在功能需求中新增專案符號.
       * 使用者互動 / 角色區分 → 更新使用者故事或角色子部分(如果存在), 包含澄清的角色、約束或場景.
       * 資料形狀 / 實體 → 更新資料模型(新增欄位、型別、關係)保持順序; 簡潔地記錄新增的約束.
       * 非功能性約束 → 在非功能性 / 品質屬性部分新增 / 修改可衡量標準(將模糊形容詞轉換為指標或明確目標).
       * 邊緣情況 / 負面流程 → 在邊緣情況 / 錯誤處理下新增新專案符號(或如果模板提供佔位符則建立此類子部分).
       * 術語衝突 → 在整個規格中規格化術語; 僅在必要時透過新增一次 `(formerly referred to as "X")` 保留原始術語.
    - 如果澄清使早期模糊宣告無效, 替換該宣告而不是重複; 不留用過時的矛盾文字.
    - 每次整合後儲存規格檔案以最小化上下文丟失風險(原子覆蓋).
    - 保持格式: 不重新排序不相關的部分; 保持標題層次結構完整.
    - 保持每個插入的澄清最小化和可測試(避免敘述性偏離).

6. 驗證(每次寫入後執行, 最終再進行一次完整檢查): 
   - 澄清會話每個接受的答案只包含一個專案符號(無重複).
   - 總共詢問(接受)的問題 ≤ 5.
   - 更新的部分不包含新答案旨在解決的持續模糊佔位符.
   - 沒有矛盾的早期宣告保留(掃描已刪除的現在無效的替代選擇).
   - Markdown 結構有效; 僅允許新標題: `## Clarifications`、`### Session YYYY-MM-DD`.
   - 術語一致性: 所有更新部分使用相同的規格術語.

7. 將更新的規格寫回 `FEATURE_SPEC`.

8. 報告完成(提問迴圈結束或提前終止後): 
   - 詢問和回答的問題數量.
   - 更新規格的路徑.
   - 涉及的部分(列出名稱).
   - 覆蓋範圍摘要表, 列出每個分類類別及狀態: 已解決(曾是部分 / 缺失並已處理)、已推遲(超過問題配額或更適合規劃)、清晰(已足夠)、未完成(仍是部分 / 缺失但影響低).
   - 如果有任何未完成或已推遲的剩餘, 建議是繼續到 `/speckit.plan` 還是在規劃後再次執行 `/speckit.clarify`.
   - 建議的下一個命令.

行為規則: 
- 如果沒有發現有意義的模糊性(或所有潛在問題都是低影響的), 回應: "No critical ambiguities detected worth formal clarification." 並建議繼續.
- 如果規格檔案缺失, 指示使用者首先執行 `/speckit.specify`(不要在此建立新規格).
- 永遠不要超過總共5個詢問的問題(單個問題的澄清重試不計為新問題).
- 避免推測性技術堆疊問題, 除非缺失阻礙功能清晰性.
- 尊重使用者提前終止訊號("stop"、"done"、"proceed").
 - 如果由於完全覆蓋而沒有提問, 輸出緊湊的覆蓋範圍摘要(所有類別清晰)然後建議前進.
 - 如果達到配額但仍有未解決的高影響類別, 在已推遲下明確標記它們並附上理由.

優先順序排序的上下文: {ARGS}
