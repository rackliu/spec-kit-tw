---
description: 在任務生成後, 對 spec.md、plan.md 和 tasks.md 執行非破壞性的跨製品一致性和品質分析.
scripts:
  sh: scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks
  ps: scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks
---

## 使用者輸入

```text
$ARGUMENTS
```

在繼續之前, 你**必須**考慮使用者輸入(如果不為空).

## 目標

在實施之前, 識別三個核心製品(`spec.md`、`plan.md`、`tasks.md`)之間的不一致、重複、模糊和規格不足的專案. 此命令**必須**在 `/speckit.tasks` 成功生成完整的 `tasks.md` 後執行.

## 操作約束

**嚴格只讀**: **不要**修改任何檔案. 輸出結構化分析報告. 提供可選的修復計劃(使用者必須明確批准後才能手動呼叫任何後續編輯命令).

**章程權威**: 專案章程(`/memory/constitution.md`)在此分析範圍內是**不可協商的**. 章程衝突自動為嚴重問題, 需要調整規格、計劃或任務——而不是稀釋、重新解釋或默默忽略原則. 如果原則本身需要更改, 那必須在 `/speckit.analyze` 之外的單獨、明確的章程更新中進行.

## 執行步驟

### 1. 初始化分析上下文

從倉庫根目錄執行一次 `{SCRIPT}` 並解析 JSON 以獲取 FEATURE_DIR 和 AVAILABLE_DOCS. 推導絕對路徑: 

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

如果任何必需檔案缺失, 則以錯誤訊息中止(指示使用者執行缺失的先決條件命令).
對於引數中的單引號, 如 "I'm Groot", 使用轉義語法: 例如 'I'\''m Groot'(或儘可能使用雙引號: "I'm Groot").

### 2. 載入製品(漸進式展示)

僅從每個製品載入最小必需的上下文: 

**從 spec.md: **

- 概述/上下文
- 功能需求
- 非功能需求
- 使用者故事
- 邊緣情況(如果存在)

**從 plan.md: **

- 架構/技術棧選擇
- 資料模型引用
- 階段
- 技術約束

**從 tasks.md: **

- 任務 ID
- 描述
- 階段分組
- 並行標記 [P]
- 引用的檔案路徑

**從章程: **

- 載入 `/memory/constitution.md` 進行原則驗證

### 3. 構建語義模型

建立內部表示(輸出中不包含原始製品): 

- **需求清單**: 每個功能和非功能需求, 帶有穩定鍵(基於祈使短語推導 slug; 例如, "User can upload file" → `user-can-upload-file`)
- **使用者故事/操作清單**: 帶有驗收標準的離散使用者操作
- **任務覆蓋對映**: 將每個任務對映到一個或多個需求或故事(透過關鍵詞/顯式引用模式推斷, 如 ID 或關鍵短語)
- **章程規則集**: 提取原則名稱和 MUST/SHOULD 規格性宣告

### 4. 檢測過程(高效令牌分析)

專注於高訊號發現. 限制總共 50 個發現; 在溢位摘要中聚合其餘部分.

#### A. 重複檢測

- 識別近似重複的需求
- 標記較低品質的表述以進行合併

#### B. 模糊性檢測

- 標記缺乏可測量標準的模糊形容詞(快速、可擴充套件、安全、直觀、穩健)
- 標記未解決的佔位符(TODO、TKTK、???、`<placeholder>` 等)

#### C. 規格不足

- 有動詞但缺少物件或可測量結果的需求
- 缺少驗收標準對齊的使用者故事
- 引用規格/計劃中未定義的檔案或元件的任務

#### D. 章程對齊

- 與 MUST 原則衝突的任何需求或計劃元素
- 章程中缺失的強制部分或品質門控

#### E. 覆蓋缺口

- 沒有關聯任務的需求
- 沒有對映需求/故事的任務
- 未在任務中反映的非功能需求(例如, 效能、安全性)

#### F. 不一致性

- 術語漂移(相同概念在不同檔案中命名不同)
- 計劃中引用但在規格中缺失的資料實體(反之亦然)
- 任務排序矛盾(例如, 整合任務在基礎設定任務之前而沒有依賴說明)
- 衝突需求(例如, 一個要求 Next.js 而另一個指定 Vue)

### 5. 嚴重性分配

使用此啟發式方法對發現進行優先順序排序: 

- **嚴重**: 違反章程 MUST、缺失核心規格製品, 或零覆蓋的需求阻止基線功能
- **高**: 重複或衝突需求、模糊的安全/效能屬性、不可測試的驗收標準
- **中**: 術語漂移、缺失非功能任務覆蓋、規格不足的邊緣情況
- **低**: 風格/措辭改進、不影響執行順序的輕微冗餘

### 6. 生成緊湊分析報告

輸出 Markdown 報告(不寫入檔案), 結構如下: 

## 規格分析報告

| ID | 類別 | 嚴重性 | 位置 | 摘要 | 建議 |
|----|------|--------|------|------|------|
| A1 | 重複 | 高 | spec.md:L120-134 | 兩個相似需求... | 合併表述; 保留更清晰的版本 |

(每個發現新增一行; 生成以類別首字母為字首的穩定 ID. )

**覆蓋摘要表: **

| 需求鍵 | 有任務？ | 任務 ID | 備註 |
|--------|----------|---------|------|

**章程對齊問題: **(如果有)

**未對映任務: **(如果有)

**指標: **

- 總需求數
- 總任務數
- 覆蓋率%(有 >=1 個任務的需求)
- 模糊性計數
- 重複計數
- 嚴重問題計數

### 7. 提供下一步操作

在報告末尾, 輸出簡潔的下一步操作塊: 

- 如果存在嚴重問題: 建議在 `/speckit.implement` 之前解決
- 如果只有低/中問題: 使用者可以繼續, 但提供改進建議
- 提供明確的命令建議: 例如, "執行 /speckit.specify 進行細化"、"執行 /speckit.plan 調整架構"、"手動編輯 tasks.md 為 'performance-metrics' 新增覆蓋"

### 8. 提供修復

詢問使用者: "你希望我為前 N 個問題建議具體的修復編輯嗎？"(不要自動應用它們. )

## 操作原則

### 上下文效率

- **最小高信噪比令牌**: 專注於可操作的發現, 而不是詳盡的文件
- **漸進式展示**: 增量載入製品; 不要將所有內容傾倒到分析中
- **高效令牌輸出**: 限制發現表為 50 行; 總結溢位部分
- **確定性結果**: 無更改重新執行應產生一致的 ID 和計數

### 分析指南

- **絕不修改檔案**(這是隻讀分析)
- **絕不虛構缺失部分**(如果缺失, 準確報告)
- **優先處理章程違規**(這些總是嚴重的)
- **使用範例而非詳盡規則**(引用具體例項, 而不是通用模式)
- **優雅報告零問題**(發出帶有覆蓋統計的成功報告)

## 上下文

{ARGS}
